---
layout: post
title: "추천 시스템 - 콘텐츠 기반 필터링, 협업 필터링, 하이브리드 필터링"
date: 2024-11-06 04:01:45 +0900
categories: 추천_시스템
---
## <span style= 'background-color: #f1f8ff'>추천 시스템
🗃️ 추천 시스템이란?\
추천 시스템은 정보 필터링 기술의 일종으로, 특정 사용자가 관심을 가질만한 정보 (영화, 음악, 책, 뉴스, 이미지, 웹 페이지 등)를 추천하는 것이다. ("추천 시스템 - 위키백과, 우리 모두의 백과사전")

🗃️ 추천 시스템의 구조\
• 후보 생성 단계: 수백만개의 아이템 중 사용자의 활동 기록을 기반으로 후보가 될 만한 수백 여개의 아이템으로 선정하는 단계이다. 이러한 후보는 일반적으로 높은 정밀도로 사용자와 관련이 있고 협업 필터링(사용자간의 유사성)을 통해서만 광범위한 개인화를 제공한다.

• 랭킹 매기는 단계: 아이템과 사용자를 설명하는 Feature을 사용하여 원하는 목적 함수에 따라 각 아이템에 점수를 할당하여 가장 높은 점수를 받은 아이템이 점수에 따라 순위가 매겨져 사용자에게 표시된다.

🗃️ 유사도?\
추천 시스템에서는 아이템 정보 데이터를 벡터화한 후, 아이템 벡터간의 유사도를 측정하고 측정된 유사도를 바탕으로 고객이 선호하는 아이템과 비교하여 유사도가 높은 아이템을 추천한다.

![image](https://github.com/user-attachments/assets/6e80c03f-558d-4090-b84d-adecc398b92f)

• 유클리디안 유사도: 두 점 사이의 최단 거리를 이용하여 서로가 얼마나 유사한지 산정한다. 값의 범위가 없으며, 스케일 차이가 크지 않을 때 주로 사용한다.
![image](https://github.com/user-attachments/assets/d9120807-5f97-4762-a917-d2d6fd4f107c)

• 코사인 유사도: 벡터간의 코사인 각도를 이용하여 서로가 얼마나 유사한지 산정한다. 값의 범위는 [-1, 1]이며 1에 가까울수록 유사하다. 스케일의 차이가 클 때 주로 사용한다.
![image](https://github.com/user-attachments/assets/adcb891f-60c0-4e90-9b77-05c57344d7cb)

⊕ 파이썬에서의 구현
```python
#함수 정의
import numpy as np

def cosine_similarity(a, b):
    return np.dot(a, b) / (np.linalg.norm(a) * (np.linalg.norm(b)))

print(cosine_similarity([3, 10, 7, 2], [2, 15, 10, 12]))

#0.9031334566143822

#scipy 이용
from scipy.spatial.distance import cosine

print(1 - cosine([3, 10, 7, 2], [2, 15, 10, 12]))

#0.9031334566143822
```

• 피어슨 유사도: 두 벡터 간의 선형 상관 관계를 측정한다. 값의 범위는 [-1, 1]이며 1에 가까울수록 유사하다.
![image](https://github.com/user-attachments/assets/838b397f-5660-4936-bf46-1cecbb1fc6e5)

⊕ 파이썬에서의 구현
```python
#함수 정의
import numpy as np

def pearson_similarity(a, b):
    return np.dot((a - np.mean(a)), (b - np.mean(b))) / ((np.linalg.norm(a - np.mean(a))) * (np.linalg.norm(b - np.mean(b))))

print(pearson_similarity([3, 10, 7, 2], [2, 15, 10, 12]))

# 0.5756777782280114

#scipy 이용
from scipy.stats import pearsonr

print(pearsonr([3, 10, 7, 2], [2, 15, 10, 12]))

# (0.5756777782280114, 0.42432222177198864)

#numpy 이용
import numpy as np

print(np.corrcoef([3, 10, 7, 2], [2, 15, 10, 12]))

""" array([[1.        , 0.57567778],
         [0.57567778, 1.        ]])"""
```

• 자카드 유사도: 공식이 매우 간단하여 빠른 계산이 필요할 때 사용한다.
![image](https://github.com/user-attachments/assets/3c50b3c8-53ce-41c5-b3c5-daa997d25b72)

⊕ 파이썬에서의 구현
```python
from math import *

def jaccard_similarity(x, y):
    intersection_cardinality = len(set.intersection(*[set(x), set(y)]))
    union_cardinality = len(set.union(*[set(x), set(y)]))

    return intersection_cardinality / float(union_cardinality)

print(jaccard_similarity(['A', 'B', 'C', 'D'], ['A', 'C', 'F', 'G']))

#0.33333333333333
```

⊕ 데이터 벡터화: 데이터를 요인들로 분석한 후 공간좌표에 표현한다. 예를 들어 요인을 3가지로 나타낸다면 다음과 같다.
![image](https://github.com/user-attachments/assets/eebb4ed6-dd8c-4f7e-8788-19ef0bca347f)

요인이 3개를 넘어갈 경우 그림으로 표현할 수는 없지만, 열벡터로 나타낼 수 있다.


## <span style= 'background-color: #f1f8ff'>콘텐츠 기반 필터링
🗃️ 콘텐츠 기반 필터링(Content-based Filtering)\
콘텐츠 자체의 특성과 사용자의 이전 행동 기록을 기반으로 사용자에게 추천한다.
![image](https://github.com/user-attachments/assets/cd994807-3b87-469f-9f00-4c0255125992)

🗃️ 콘텐츠 기반 필터링 모델의 알고리즘\
➀ 아이템의 설명으로부터 아이템의 특징을 추출한다. 이때 아이템의 설명을 모델이 이해할 수 있는 형태인 벡터로 변환한다.\
➁ 모델을 이용하여 과거에 좋게 평가했던 아이템 A와 유사한 아이템들을 선별한다. 아이템 사이의 유사성을 무엇으로 파악하고 어떻게 계산할지가 콘텐츠 기반 필터링의 핵심이다.

🔎 유사 컨텐츠 찾기: 앞서 설명한 벡터간 유사도 계산을 이용한다. 코사인 유사도, 피어슨 유사도 등을 이용할 수 있다.

🗃️ 콘텐츠 기반 필터링의 장점\
• 다른 사용자들의 데이터가 없어도 추천이 가능하다.\
• 새로 추가된 아이템, 평점이 없는 유명하지 않은 아이템도 추천이 가능하다. 아이템의 설명만 있다면 다양한 아이템이 후보군이 될 수 있기 때문.\
• 추천을 하는 근거를 설명할 수 있다.

🗃️ 콘텐츠 기반 필터링의 단점\
• 아이템의 설명을 구성하는 과정에서 주관성이 개입될 수 있다. 사용자 A는 영화 X를 흥미진진하다, 박진감 넘친다고 평가할 수 있지만, 반대로 사용자 B는 동일한 영화를 두고 폭력적이라고 평가할 수 있다.\
• 사용자가 과거에 좋아했던 아이템을 제공하지 않으면 추천이 어렵다. 사용자가 아이템을 제공하지 않을 경우 단순 프로필을 이용하여 아이템을 제공하고, 이후에 사용이력이 쌓이면 그때부터 개인화 추천을 시도할 수 있다.\
• 아이템 속성 정보 간의 연관성을 바탕으로 하기 때문에 사용자가 이미 알고 있거나, 알고 있는 것과 유사한 아이템만을 주로 추천하는 문제가 발생한다.


## <span style= 'background-color: #f1f8ff'>협업 필터링
🗃️ 협업 필터링(Collaborative Filtering)\
다른 사용자들로부터 취향 정보들을 모아 사용자의 관심사를 예측하는 방법이다. 협업 필터링은 비슷한 취향을 가진 사용자들은 어떠한 아이템에 대해 비슷한 선호도를 가질 것이라는 가정 하에 사용자와 아이템 간 상호 작용 데이터를 활용한다.
![image](https://github.com/user-attachments/assets/3c542fe7-60ac-4e20-bc30-7e427b24b2d6)

🗃️ 협업 필터링 모델의 유형\
• 메모리 기반 접근 방식: 유사도를 기반으로 동작한다. 사용자 간 유사도를 기준으로 그룹이 선호하는 상품을 해당 그룹에 속한 사용자에게 추천하는 사용자 기반 추천, 사용자가 이전에 구매했던 아이템을 기반으로 그 상품과 유사한 다른 상품을 추천하는 아이템 기반 추천이 있다.

• 모델 기반 접근 방식: 기계 학습을 통해 사용자 또는 아이템의 숨겨진 특성 값을 계산하는 방식이다. 모델 기반의 접근 방식에는 잠재요인을 이용한 Latent Factor 방식과 Classification/Regression 방식 및 최신 융합 모델 방식을 이용한 다양한 접근 방식이 있다.\
➀ Latent Facotr 모델: 사용자와 아이템들을 잠재적인 차원들을 사용해 나타낼 수 있다고 가정하는 모델이다. 예를 들어 x축은 성별을 나타내고, y축은 영화의 장르를 나타낸다면 사용자와 아이템은 좌표평면 위의 적절한 x, y 값에 매핑된다는 의미이다.\
➁ Classification/Regression 방식: 피처 X가 주어졌을 때, 라벨 Y를 예측하는 구조. Classification은 유저의 성향에 따라 군집을 분류하여 성향이 부여된 군집에 맞추어 아이템을 추천해주는 방식이고, Regression은 유저와 아이템에 대한 평균 평점을 구하는 모델을 통해 새로운 카테고리에서 예측값을 추천하는 방식이다.\
➂ 최신 융합 모델 방식: Latent Factor 모델과 Classification/Regression 모델의 특징을 모두 가진 Factorization Machine, 딥러닝을 활용하여 Latent Factor 모델을 확장한 Neural Collaborative Filtering도 제시되었다.

🗃️ 협업 필터링 모델의 알고리즘\
• 메모리 기반 접근 방식: 두 사용자 간의 유사도는 두 벡터 간의 유사도로 정의하며 코사인 유사도, 피어슨 유사도 등을 이용해 유사도를 계산한다.

• 모델 기반 접근 방식: 머신러닝 알고리즘을 통해, 사용자가 아직 평가하지 않은 아이템의 평점을 예측한다. 사용자의 선호도가 소수의 잠재된 요인으로 결정될 수 있다는 아이디어를 바탕으로 하기 때문에 행렬 분해를 이용하여 잠재된 요인을 추출한다.

행렬 분해는 User-Item Matrix를 F차원의 User와 Item의 Latent factor 행렬곱으로 분해하는 방법을 말한다.

![image](https://github.com/user-attachments/assets/8fded499-3d63-4054-8ce0-97cd1d2cbb6c)

🗃️ 협업 필터링의 장점\
• 결과가 직관적이다.\
• 상품 자체에 대한 정보 없이 추천이 가능하다.\

🗃️ 협업 필터링의 단점\
• 새로운 항목 추천에 한계가 있는 콜드 스타트 문제가 있다.\
• 관심이 저조한 상품은 정보가 부족하여 추천이 어렵다.\
• 계산량이 많아 사용자가 많아질수록 추천의 효율성이 떨어진다.


## <span style= 'background-color: #f1f8ff'>하이브리드 필터링
🗃️ 하이브리드 필터링(Hybrid Filtering)\
협업 필터링과 콘텐츠 기반 필터링을 조합한 새로운 알고리즘으로, 두 시스템의 장점들을 합하면 더 좋은 알고리즘이 나오지 않을까라는 아이디어를 시작으로 만들어진 필터링 방법이다. 협업 필터링의 콜드 스타트 문제를 해결하기 위해 신규 콘텐츠들은 콘텐츠 기반 필터링으로 분석을 진행한 후 충분한 데이터가 쌓이게 된다면 협업 필터링으로 정확성을 높이는 방식으로 진행된다.

🗃️ 하이브리드 필터링의 다양한 전략\
➀ 다른 추천 기준을 지닌 여러 개의 알고리즘을 학습한 뒤, 각 알고리즘이 아이템 추천 점수의 가중평균합을 구하는 방법.\
➁ 학습된 여러 개의 추천 엔진 중에서 현재의 상황에 가장 적절한 추천 엔진을 선택하는 방법.\
➂ 각 알고리즘들의 추천 결과를 혼합하여 보여주는 방법.\
➃ 각각의 알고리즘에 사용되는 모든 변수를 하나의 알고리즘의 변수로 병합하여 이용하는 방법.\
➄ 한 알고리즘이 추천한 아이템을 다음 알고리즘의 후보로 이용하여 각 단계별로 더 세밀하게 추천하거나 한 알고리즘의 추천 점수를 다른 알고리즘의 변수로 이용하는 방법.\
➅ 각각의 알고리즘의 추천 점수를 바탕으로 메타 알고리즘을 학습하는 앙상블 방법.

